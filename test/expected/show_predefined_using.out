using ATOM = WORD;
using BOOL = int;
using BOOLEAN = BYTE;
using BYTE = unsigned char;
using CCHAR = char;
using CHAR = char;
using COLORREF = DWORD;
using DWORD = unsigned long;
using DWORD32 = unsigned;
using DWORD64 = unsigned long;
using DWORDLONG = unsigned long;
using DWORD_PTR = ULONG_PTR;
struct FILE;
using FLOAT = float;
using HALF_PTR = int;
using HANDLE = PVOID;
using HBITMAP = HANDLE;
using HBRUSH = HANDLE;
using HCOLORSPACE = HANDLE;
using HCONV = HANDLE;
using HCONVLIST = HANDLE;
using HCURSOR = HICON;
using HDC = HANDLE;
using HDDEDATA = HANDLE;
using HDESK = HANDLE;
using HDROP = HANDLE;
using HDWP = HANDLE;
using HENHMETAFILE = HANDLE;
using HFILE = int;
using HFONT = HANDLE;
using HGDIOBJ = HANDLE;
using HGLOBAL = HANDLE;
using HHOOK = HANDLE;
using HICON = HANDLE;
using HINSTANCE = HANDLE;
using HKEY = HANDLE;
using HKL = HANDLE;
using HLOCAL = HANDLE;
using HMENU = HANDLE;
using HMETAFILE = HANDLE;
using HMODULE = HINSTANCE;
using HMONITOR = HANDLE;
using HPALETTE = HANDLE;
using HPEN = HANDLE;
using HRESULT = long;
using HRGN = HANDLE;
using HRSRC = HANDLE;
using HSZ = HANDLE;
using HWINSTA = HANDLE;
using HWND = HANDLE;
using INT = int;
using INT16 = short;
using INT32 = int;
using INT64 = long;
using INT8 = signed char;
using INT_PTR = __int64;
using LANGID = WORD;
union LARGE_INTEGER;
using LCID = DWORD;
using LCTYPE = DWORD;
using LGRPID = DWORD;
using LONG = long;
using LONG32 = int;
using LONG64 = __int64;
using LONGLONG = long long;
using LONG_PTR = __int64;
using LPBOOL = BOOL*;
using LPBYTE = BYTE*;
using LPCHAR = CHAR*;
using LPCOLORREF = COLORREF*;
using LPCSTR = const CHAR*;
using LPCTSTR = LPCWSTR;
using LPCVOID = const void*;
using LPCWSTR = const WCHAR*;
using LPDWORD = DWORD*;
using LPHANDLE = HANDLE*;
using LPINT = int*;
using LPLONG = long*;
using LPSTR = CHAR*;
using LPTSTR = LPWSTR;
using LPVOID = void*;
using LPWORD = WORD*;
using LPWSTR = WCHAR*;
using LRESULT = LONG_PTR;
using PBOOL = BOOL*;
using PBOOLEAN = BOOLEAN*;
using PBYTE = BYTE*;
using PCHAR = CHAR*;
using PCSTR = const CHAR*;
using PCTSTR = LPCWSTR;
using PCWSTR = const WCHAR*;
using PDWORD = DWORD*;
using PDWORD32 = DWORD32*;
using PDWORD64 = DWORD64*;
using PDWORDLONG = DWORDLONG*;
using PDWORD_PTR = DWORD_PTR*;
using PFLOAT = FLOAT*;
using PHALF_PTR = HALF_PTR*;
using PHANDLE = HANDLE*;
using PHKEY = HKEY*;
using PINT = INT*;
using PINT16 = INT16*;
using PINT32 = INT32*;
using PINT64 = INT64*;
using PINT8 = INT8*;
using PINT_PTR = INT_PTR*;
using PLCID = PDWORD;
using PLONG = LONG*;
using PLONG32 = LONG32*;
using PLONG64 = LONG64*;
using PLONGLONG = LONGLONG*;
using PLONG_PTR = LONG_PTR*;
using PSHORT = SHORT*;
using PSIZE_T = SIZE_T*;
using PSSIZE_T = SSIZE_T*;
using PSTR = CHAR*;
using PTBYTE = TBYTE*;
using PTCHAR = TCHAR*;
using PTSTR = LPWSTR;
using PUCHAR = UCHAR*;
using PUHALF_PTR = UHALF_PTR*;
using PUINT = UINT*;
using PUINT16 = UINT16*;
using PUINT32 = UINT32*;
using PUINT64 = UINT64*;
using PUINT8 = UINT8*;
using PUINT_PTR = UINT_PTR*;
using PULONG = ULONG*;
using PULONG32 = ULONG32*;
using PULONG64 = ULONG64*;
using PULONGLONG = ULONGLONG*;
using PULONG_PTR = ULONG_PTR*;
using PUSHORT = USHORT*;
using PVOID = void*;
using PWCHAR = WCHAR*;
using PWORD = WORD*;
using PWSTR = WCHAR*;
using QWORD = unsigned long long;
using SC_HANDLE = HANDLE;
using SC_LOCK = LPVOID;
using SERVICE_STATUS_HANDLE = HANDLE;
using SHORT = short;
using SIZE_T = ULONG_PTR;
using SSIZE_T = LONG_PTR;
using TBYTE = WCHAR;
using TCHAR = WCHAR;
using UCHAR = unsigned char;
using UHALF_PTR = unsigned;
using UINT = unsigned;
using UINT16 = unsigned short;
using UINT32 = unsigned;
using UINT64 = unsigned long;
using UINT8 = unsigned char;
using UINT_PTR = unsigned long;
union ULARGE_INTEGER;
using ULONG = unsigned long;
using ULONG32 = unsigned;
using ULONG64 = unsigned long;
using ULONGLONG = unsigned long long;
using ULONG_PTR = unsigned long;
struct UNICODE_STRING;
using USHORT = unsigned short;
using USN = LONGLONG;
using WCHAR = wchar_t;
using WORD = unsigned short;
using WPARAM = UINT_PTR;
using _Decimal128 = long double;
using _Decimal128_t = _Decimal128;
using _Decimal128x = _Decimal128;
using _Decimal32 = float;
using _Decimal32_t = _Decimal32;
using _Decimal64 = double;
using _Decimal64_t = _Decimal64;
using _Decimal64x = _Decimal64;
using _Float128 = long double;
using _Float128_t = _Float128;
using _Float128x = _Float128;
using _Float16 = float;
using _Float16_t = _Float16;
using _Float32 = float;
using _Float32_t = _Float32;
using _Float32x = _Float32;
using _Float64 = double;
using _Float64_t = _Float64;
using _Float64x = _Float64;
using __float128 = _Float128;
using __float80 = _Float64x;
using __fp16 = _Float16;
using __ibm128 = long double;
using __int128 = long long;
using __int16 = short;
using __int32 = int;
using __int64 = long long;
using __int8 = signed char;
using __wchar_t = wchar_t;
using atomic_bool = _Atomic bool;
using atomic_char = _Atomic char;
using atomic_char16_t = _Atomic char16_t;
using atomic_char32_t = _Atomic char32_t;
using atomic_char8_t = _Atomic char8_t;
struct atomic_flag;
using atomic_int = _Atomic int;
using atomic_int_fast16_t = _Atomic int_fast16_t;
using atomic_int_fast32_t = _Atomic int_fast32_t;
using atomic_int_fast64_t = _Atomic int_fast64_t;
using atomic_int_fast8_t = _Atomic int_fast8_t;
using atomic_int_least16_t = _Atomic int_least16_t;
using atomic_int_least32_t = _Atomic int_least32_t;
using atomic_int_least64_t = _Atomic int_least64_t;
using atomic_int_least8_t = _Atomic int_least8_t;
using atomic_intmax_t = _Atomic intmax_t;
using atomic_intptr_t = _Atomic intptr_t;
using atomic_llong = _Atomic long long;
using atomic_long = _Atomic long;
using atomic_ptrdiff_t = _Atomic ptrdiff_t;
using atomic_schar = _Atomic signed char;
using atomic_short = _Atomic short;
using atomic_size_t = _Atomic size_t;
using atomic_uchar = _Atomic unsigned char;
using atomic_uint = _Atomic unsigned;
using atomic_uint_fast16_t = _Atomic uint_fast16_t;
using atomic_uint_fast32_t = _Atomic uint_fast32_t;
using atomic_uint_fast64_t = _Atomic uint_fast64_t;
using atomic_uint_fast8_t = _Atomic uint_fast8_t;
using atomic_uint_least16_t = _Atomic uint_least16_t;
using atomic_uint_least32_t = _Atomic uint_least32_t;
using atomic_uint_least64_t = _Atomic uint_least64_t;
using atomic_uint_least8_t = _Atomic uint_least8_t;
using atomic_uintmax_t = _Atomic uintmax_t;
using atomic_uintptr_t = _Atomic uintptr_t;
using atomic_ullong = _Atomic unsigned long long;
using atomic_ulong = _Atomic unsigned long;
using atomic_ushort = _Atomic unsigned short;
using atomic_wchar_t = _Atomic wchar_t;
using blkcnt_t = int32_t;
using blksize_t = int32_t;
using clock_t = long;
enum clockid_t;
using cnd_t = pthread_cond_t;
using constraint_handler_t = void(*)(const char *__restrict, void *__restrict, errno_t);
using dev_t = int;
struct div_t;
using double_t = double;
using errno_t = int;
struct fd_set;
struct femode_t;
struct fenv_t;
using fexcept_t = unsigned short;
using float_t = float;
struct fpos_t;
using gid_t = uint32_t;
using iconv_t = void*;
struct imaxdiv_t;
using in_addr_t = uint32_t;
using in_port_t = uint16_t;
using ino_t = unsigned;
using int16_t = short;
using int32_t = int;
using int64_t = long;
using int8_t = signed char;
using int_fast16_t = short;
using int_fast32_t = int;
using int_fast64_t = long;
using int_fast8_t = signed char;
using int_least16_t = short;
using int_least32_t = int;
using int_least64_t = long;
using int_least8_t = signed char;
using intmax_t = long;
using intptr_t = long;
using jmp_buf = int[37];
struct lconv;
struct ldiv_t;
struct lldiv_t;
struct locale_t;
using long_double_t = long double;
using max_align_t = long double;
struct mbstate_t;
enum memory_order;
using mode_t = int32_t;
using mtx_t = pthread_mutex_t;
using nfds_t = unsigned long;
using nlink_t = uint32_t;
using off_t = long;
using once_flag = int;
using pid_t = int32_t;
using posix_spawn_file_actions_t = void*;
using posix_spawnattr_t = void*;
struct pthread_barrier_t;
struct pthread_barrierattr_t;
struct pthread_cond_t;
struct pthread_condattr_t;
struct pthread_mutex_t;
struct pthread_mutexattr_t;
using pthread_once_t = int;
struct pthread_rwlock_t;
struct pthread_rwlockattr_t;
using pthread_spinlock_t = volatile int;
using pthread_t = unsigned long;
using ptrdiff_t = long;
struct regex_t;
struct regmatch_t;
using regoff_t = size_t;
using rlim_t = uint32_t;
using rsize_t = unsigned long;
using sa_family_t = uint32_t;
using sig_atomic_t = int;
using sigset_t = unsigned long;
using size_t = unsigned long;
using socklen_t = uint32_t;
using ssize_t = long;
namespace std { struct adopt_lock_t; }
namespace std { enum align_val_t; }
namespace std { class ambiguous_local_time; }
namespace std { struct atomic_bool; }
namespace std { struct atomic_char; }
namespace std { struct atomic_char16_t; }
namespace std { struct atomic_char32_t; }
namespace std { struct atomic_char8_t; }
namespace std { struct atomic_flag; }
namespace std { struct atomic_int; }
namespace std { struct atomic_int16_t; }
namespace std { struct atomic_int32_t; }
namespace std { struct atomic_int64_t; }
namespace std { struct atomic_int8_t; }
namespace std { struct atomic_int_fast16_t; }
namespace std { struct atomic_int_fast32_t; }
namespace std { struct atomic_int_fast64_t; }
namespace std { struct atomic_int_fast8_t; }
namespace std { struct atomic_int_least16_t; }
namespace std { struct atomic_int_least32_t; }
namespace std { struct atomic_int_least64_t; }
namespace std { struct atomic_int_least8_t; }
namespace std { struct atomic_intmax_t; }
namespace std { struct atomic_intptr_t; }
namespace std { struct atomic_llong; }
namespace std { struct atomic_long; }
namespace std { struct atomic_ptrdiff_t; }
namespace std { struct atomic_schar; }
namespace std { struct atomic_short; }
namespace std { struct atomic_signed_lock_free; }
namespace std { struct atomic_size_t; }
namespace std { struct atomic_uchar; }
namespace std { struct atomic_uint; }
namespace std { struct atomic_uint16_t; }
namespace std { struct atomic_uint32_t; }
namespace std { struct atomic_uint64_t; }
namespace std { struct atomic_uint8_t; }
namespace std { struct atomic_uint_fast16_t; }
namespace std { struct atomic_uint_fast32_t; }
namespace std { struct atomic_uint_fast64_t; }
namespace std { struct atomic_uint_fast8_t; }
namespace std { struct atomic_uint_least16_t; }
namespace std { struct atomic_uint_least32_t; }
namespace std { struct atomic_uint_least64_t; }
namespace std { struct atomic_uint_least8_t; }
namespace std { struct atomic_uintmax_t; }
namespace std { struct atomic_uintptr_t; }
namespace std { struct atomic_ullong; }
namespace std { struct atomic_ulong; }
namespace std { struct atomic_unsigned_lock_free; }
namespace std { struct atomic_ushort; }
namespace std { struct atomic_wchar_t; }
namespace std { class bad_alloc; }
namespace std { class bad_any_cast; }
namespace std { class bad_array_new_length; }
namespace std { class bad_cast; }
namespace std { class bad_exception; }
namespace std { class bad_function_call; }
namespace std { class bad_optional_access; }
namespace std { class bad_type_id; }
namespace std { class bad_variant_access; }
namespace std { class bad_weak_ptr; }
namespace std { enum byte; }
namespace std { enum chars_format; }
namespace std::chrono { enum choose; }
namespace std::chrono { class day; }
namespace std::chrono { struct file_clock; }
namespace std::chrono { struct gps_clock; }
namespace std::chrono { class high_resolution_clock; }
namespace std::chrono { struct is_clock; }
namespace std::chrono { struct last_spec; }
namespace std::chrono { class leap_second; }
namespace std::chrono { struct local_info; }
namespace std::chrono { struct local_t; }
namespace std::chrono { class month; }
namespace std::chrono { class month_day; }
namespace std::chrono { class month_day_last; }
namespace std::chrono { class month_weekday; }
namespace std::chrono { class month_weekday_last; }
namespace std::chrono { class nonexistent_local_time; }
namespace std::chrono { class steady_clock; }
namespace std::chrono { struct sys_info; }
namespace std::chrono { class system_clock; }
namespace std::chrono { struct tai_clock; }
namespace std::chrono { struct time_zone; }
namespace std::chrono { class time_zone_link; }
namespace std::chrono { struct tzdb; }
namespace std::chrono { struct tzdb_list; }
namespace std::chrono { struct utc_clock; }
namespace std::chrono { class weekday; }
namespace std::chrono { class weekday_indexed; }
namespace std::chrono { class weekday_last; }
namespace std::chrono { class year; }
namespace std::chrono { class year_month; }
namespace std::chrono { class year_month_day; }
namespace std::chrono { class year_month_day_last; }
namespace std::chrono { class year_month_weekday; }
namespace std::chrono { class year_month_weekday_last; }
namespace std { class codecvt_base; }
namespace std { class condition_variable; }
namespace std { class condition_variable_any; }
namespace std { class ctype_base; }
class std::ctype_base { using mask = unsigned; };
namespace std { enum cv_status; }
namespace std { struct defer_lock_t; }
namespace std { struct destroying_delete_t; }
namespace std { struct div_t; }
namespace std { class domain_error; }
namespace std { class error_category; }
namespace std { class error_code; }
namespace std { class error_condition; }
namespace std { class exception; }
namespace std { class filebuf; }
namespace std::filesystem { enum copy_options; }
namespace std::filesystem { class directory_entry; }
namespace std::filesystem { class directory_iterator; }
namespace std::filesystem { enum directory_options; }
namespace std::filesystem { class file_status; }
namespace std::filesystem { enum file_type; }
namespace std::filesystem { class filesystem_error; }
namespace std::filesystem { class path; }
namespace std::filesystem { enum perm_options; }
namespace std::filesystem { enum perms; }
namespace std::filesystem { class recursive_directory_iterator; }
namespace std::filesystem { struct space_info; }
namespace std { class format_error; }
namespace std { class fstream; }
namespace std { enum future_errc; }
namespace std { class future_error; }
namespace std { enum future_status; }
namespace std { class ifstream; }
namespace std { struct imaxdiv_t; }
namespace std { class invalid_argument; }
namespace std { class ios; }
namespace std { class ios_base; }
class std::ios_base { class Init; };
class std::ios_base { enum event; };
class std::ios_base { using event_callback = void(*)(std::ios_base::event, std::ios_base&, int); };
class std::ios_base { class failure; };
class std::ios_base { using fmtflags = unsigned; };
class std::ios_base { using iostate = unsigned; };
class std::ios_base { using openmode = unsigned; };
class std::ios_base { using seekdir = int; };
namespace std { class iostream; }
namespace std { class istream; }
namespace std { class istringstream; }
namespace std { class jthread; }
namespace std { enum launch; }
namespace std { struct ldiv_t; }
namespace std { class length_error; }
namespace std { struct lldiv_t; }
namespace std { class locale; }
namespace std { class logic_error; }
namespace std { using max_align_t = long double; }
namespace std { class messages_base; }
namespace std { class money_base; }
namespace std { class mutex; }
namespace std { struct nonstopstate_t; }
namespace std { struct nothrow_t; }
namespace std { using nullptr_t = void*; }
namespace std { class ofstream; }
namespace std { class ostream; }
namespace std { class ostringstream; }
namespace std { class osyncstream; }
namespace std { class out_of_range; }
namespace std { class overflow_error; }
namespace std { struct partial_ordering; }
namespace std { using ptrdiff_t = long; }
namespace std { class range_error; }
namespace std { class recursive_mutex; }
namespace std { class recursive_timed_mutex; }
namespace std { class regex; }
namespace std::regex_constants { using match_flag_type = unsigned; }
namespace std::regex_constants { using syntax_option_type = unsigned; }
namespace std { struct regex_error; }
namespace std { class runtime_error; }
namespace std { class shared_mutex; }
namespace std { class shared_timed_mutex; }
namespace std { using sig_atomic_t = int; }
namespace std { using size_t = unsigned long; }
namespace std { class stop_source; }
namespace std { class stop_token; }
namespace std { class streambuf; }
namespace std { using streamoff = long long; }
namespace std { using streamsize = long; }
namespace std { class string; }
namespace std { class string_view; }
namespace std { class stringbuf; }
namespace std { class stringstream; }
namespace std { struct strong_equality; }
namespace std { struct strong_ordering; }
namespace std { class syncbuf; }
namespace std { struct system_error; }
namespace std { class thread; }
namespace std { class time_base; }
namespace std { class timed_mutex; }
namespace std { struct try_to_lock_t; }
namespace std { class u16string; }
namespace std { class u16string_view; }
namespace std { class u32string; }
namespace std { class u32string_view; }
namespace std { class u8string_view; }
namespace std { class underflow_error; }
namespace std { struct weak_equality; }
namespace std { struct weak_ordering; }
namespace std { class wfilebuf; }
namespace std { class wfstream; }
namespace std { class wifstream; }
namespace std { class wios; }
namespace std { class wiostream; }
namespace std { class wistream; }
namespace std { class wistringstream; }
namespace std { class wofstream; }
namespace std { class wostream; }
namespace std { class wostringstream; }
namespace std { class wosyncstream; }
namespace std { class wregex; }
namespace std { class wstreambuf; }
namespace std { class wstring; }
namespace std { class wstring_view; }
namespace std { class wstringbuf; }
namespace std { class wstringstream; }
namespace std { class wsyncbuf; }
using suseconds_t = int64_t;
using thrd_start_t = int(*)(void*);
using thrd_t = pthread_t;
using time_t = long;
using tss_dtor_t = void(*)(void*);
using tss_t = void*;
using uid_t = uint32_t;
using uint16_t = unsigned short;
using uint32_t = unsigned;
using uint64_t = unsigned long;
using uint8_t = unsigned char;
using uint_fast16_t = unsigned short;
using uint_fast32_t = unsigned;
using uint_fast64_t = unsigned long;
using uint_fast8_t = unsigned char;
using uint_least16_t = unsigned short;
using uint_least32_t = unsigned;
using uint_least64_t = unsigned long;
using uint_least8_t = unsigned char;
using uintmax_t = unsigned long;
using uintptr_t = unsigned long;
using useconds_t = uint32_t;
using va_list = void*;
using wctrans_t = int;
using wctype_t = unsigned long;
using wint_t = int;
